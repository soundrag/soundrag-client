<br>
<div align="center">

**Soundrag**는 스피커 배치에 따라 소리의 변화를 느낄 수 있는
**3D 공간 음향 시뮬레이터** 입니다.

  <br>

<a target="blank" href="https://soundrag.co.kr/">
  <img width="300px" alt="project icon" src="https://github.com/user-attachments/assets/8f54c1ef-ac76-4dc0-a35a-4bc50a165fcc">
</a>

  <br>
  <br>

[<img src="https://github.com/user-attachments/assets/c0e202b2-b44d-4fb0-908c-e26cfe5264e0">](https://soundrag.co.kr/)

  <br>

_스피커를 이동하거나 최적의 위치를 찾는 것은 시간과 노력이 많이 소요됩니다._<br>
_이러한 문제를 해결하기 위해 3D 가상 공간에서 스피커를 자유롭게 배치할 수 있는 환경을 구현하였습니다._

</div>

<br>
<span id="top"></span>
<br>

## 목차

<!-- toc -->

- [1. 움직이는 스피커로 소리를 바꾸기](#1-%EC%9B%80%EC%A7%81%EC%9D%B4%EB%8A%94-%EC%8A%A4%ED%94%BC%EC%BB%A4%EB%A1%9C-%EC%86%8C%EB%A6%AC%EB%A5%BC-%EB%B0%94%EA%BE%B8%EA%B8%B0)
  - [1-1. 마우스로 3D 스피커 모델 조작하기](#1-1-%EB%A7%88%EC%9A%B0%EC%8A%A4%EB%A1%9C-3d-%EC%8A%A4%ED%94%BC%EC%BB%A4-%EB%AA%A8%EB%8D%B8-%EC%A1%B0%EC%9E%91%ED%95%98%EA%B8%B0)
    - [(1) 다양한 해상도에서 매끄럽게 움직이려면?](#1-%EB%8B%A4%EC%96%91%ED%95%9C-%ED%95%B4%EC%83%81%EB%8F%84%EC%97%90%EC%84%9C-%EB%A7%A4%EB%81%84%EB%9F%BD%EA%B2%8C-%EC%9B%80%EC%A7%81%EC%9D%B4%EB%A0%A4%EB%A9%B4)
    - [(2) 2D 화면에서 3D 모델의 좌표 구하기](#2-2d-%ED%99%94%EB%A9%B4%EC%97%90%EC%84%9C-3d-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EC%A2%8C%ED%91%9C-%EA%B5%AC%ED%95%98%EA%B8%B0)
    - [(3) 마우스와 3D 모델의 실시간 상호작용](#3-%EB%A7%88%EC%9A%B0%EC%8A%A4%EC%99%80-3d-%EB%AA%A8%EB%8D%B8%EC%9D%98-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%83%81%ED%98%B8%EC%9E%91%EC%9A%A9)
  - [1-2. 스피커의 위치로 소리를 바꾸는 방식](#1-2-%EC%8A%A4%ED%94%BC%EC%BB%A4%EC%9D%98-%EC%9C%84%EC%B9%98%EB%A1%9C-%EC%86%8C%EB%A6%AC%EB%A5%BC-%EB%B0%94%EA%BE%B8%EB%8A%94-%EB%B0%A9%EC%8B%9D)
    - [(1) 멀리 갈수록 약해지는 소리](#1-%EB%A9%80%EB%A6%AC-%EA%B0%88%EC%88%98%EB%A1%9D-%EC%95%BD%ED%95%B4%EC%A7%80%EB%8A%94-%EC%86%8C%EB%A6%AC)
    - [(2) 좌우 위치에 따라 달라지는 소리](#2-%EC%A2%8C%EC%9A%B0-%EC%9C%84%EC%B9%98%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%8B%AC%EB%9D%BC%EC%A7%80%EB%8A%94-%EC%86%8C%EB%A6%AC)
    - [(3) 천장과 바닥의 소리 차이: 주파수](#3-%EC%B2%9C%EC%9E%A5%EA%B3%BC-%EB%B0%94%EB%8B%A5%EC%9D%98-%EC%86%8C%EB%A6%AC-%EC%B0%A8%EC%9D%B4-%EC%A3%BC%ED%8C%8C%EC%88%98)
- [2. 사용자 편의성을 위한 도전들](#2-%EC%82%AC%EC%9A%A9%EC%9E%90-%ED%8E%B8%EC%9D%98%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%8F%84%EC%A0%84%EB%93%A4)
  - [2-1. 잊어버려도 괜찮아요, 자동 저장](#2-1-%EC%9E%8A%EC%96%B4%EB%B2%84%EB%A0%A4%EB%8F%84-%EA%B4%9C%EC%B0%AE%EC%95%84%EC%9A%94-%EC%9E%90%EB%8F%99-%EC%A0%80%EC%9E%A5)
    - [(1) 저장 버튼만 존재하는 불편한 세상](#1-%EC%A0%80%EC%9E%A5-%EB%B2%84%ED%8A%BC%EB%A7%8C-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94-%EB%B6%88%ED%8E%B8%ED%95%9C-%EC%84%B8%EC%83%81)
    - [(2) 자동 저장 구현하기](#2-%EC%9E%90%EB%8F%99-%EC%A0%80%EC%9E%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)
    - [(3) 자동 저장이 가져다주는 편리함](#3-%EC%9E%90%EB%8F%99-%EC%A0%80%EC%9E%A5%EC%9D%B4-%EA%B0%80%EC%A0%B8%EB%8B%A4%EC%A3%BC%EB%8A%94-%ED%8E%B8%EB%A6%AC%ED%95%A8)
  - [2-2. 빠른 속도의 비밀, 프리로드](#2-2-%EB%B9%A0%EB%A5%B8-%EC%86%8D%EB%8F%84%EC%9D%98-%EB%B9%84%EB%B0%80-%ED%94%84%EB%A6%AC%EB%A1%9C%EB%93%9C)
    - [(1) 느린 네트워크를 극복하기 위한 고민](#1-%EB%8A%90%EB%A6%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EB%A5%BC-%EA%B7%B9%EB%B3%B5%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EA%B3%A0%EB%AF%BC)
    - [(2) 프리로드 구현하기](#2-%ED%94%84%EB%A6%AC%EB%A1%9C%EB%93%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)
    - [(3) 프리로드가 가져다주는 편리함](#3-%ED%94%84%EB%A6%AC%EB%A1%9C%EB%93%9C%EA%B0%80-%EA%B0%80%EC%A0%B8%EB%8B%A4%EC%A3%BC%EB%8A%94-%ED%8E%B8%EB%A6%AC%ED%95%A8)
- [3. 구현하며 배운 점들](#3-%EA%B5%AC%ED%98%84%ED%95%98%EB%A9%B0-%EB%B0%B0%EC%9A%B4-%EC%A0%90%EB%93%A4)

<!-- tocstop -->

<br>
<br>

## 기술 스택

### Client

![React](https://img.shields.io/badge/react-%23404d59.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB)
![Vite](https://img.shields.io/badge/vite-%23404d59.svg?style=for-the-badge&logo=vite&logoColor=w)
![Axios](https://img.shields.io/badge/axios-%23404d59.svg?style=for-the-badge&logo=axios&logoColor=w)
![ThreeJS](https://img.shields.io/badge/Three.js-404d59?style=for-the-badge&logo=Three.js&logoColor=w)
![Zustand](https://img.shields.io/badge/zustand-%23404d59.svg?style=for-the-badge&logo=react&logoColor=black)
![Styled-components](https://img.shields.io/badge/styled_component-404d59.svg?style=for-the-badge&logo=styledcomponents&logoColor=DB7093)

### Server

![NodeJS](https://img.shields.io/badge/node.js-404d59?style=for-the-badge&logo=node.js&logoColor=6DA55F)
![Express.js](https://img.shields.io/badge/express.js-%23404d59.svg?style=for-the-badge&logo=express&logoColor=%2361DAFB)
![MongoDB & Mongoose](https://img.shields.io/badge/MongoDB%20&%20Mongoose-%23404d59.svg?style=for-the-badge&logo=mongodb&logoColor=w)

### Deploy

![Firebase](https://img.shields.io/badge/firebase-%23404d59.svg?style=for-the-badge&logo=firebase&logoColor=red)
![Amazon Web Service](https://img.shields.io/badge/amazon%20web%20service-%23404d59.svg?style=for-the-badge&logo=amazon&logoColor=b)

### Test

![Vitest](https://img.shields.io/badge/vitest-%23404d59.svg?style=for-the-badge&logo=vitest&logoColor=sd)
![Playwright](https://img.shields.io/badge/playwright-%23404d59.svg?style=for-the-badge&logo=playwright&logoColor=sd)

<br>
<br>

## 1. 움직이는 스피커로 소리를 바꾸기

사용자가 3D 공간에서 스피커를 움직이며 소리의 변화를 체험할 수 있도록, 다음과 같은 주요 기능을 구현하였습니다.

- **2D 화면에서의 3D 모델 움직임**: 사용자가 마우스를 통해 3D 모델을 드래그할 수 있도록, 2D 화면과 3D 공간 간의 **좌표 변환** 및 **드래그 이벤트 처리**를 구현하였습니다.

- **3D 공간에서 위치에 따른 소리 변화**: 스피커의 배치에 따라 달라지는 소리의 특성을 제공하기 위해, **세 가지의 위치 기반 음향 변화**를 구현하였습니다.

<br>

| 2D 화면에서 3D 모델 움직임                                                                                             | 3D 공간에서 위치에 따른 소리 변화                                                                                    |
| ---------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| <img width="360" height="260" src="https://github.com/user-attachments/assets/2d918e2e-dcae-41a2-8f5a-e56128977869  "> | <img width="360" height="260" src="https://github.com/user-attachments/assets/2e93699e-7fa4-4277-bda4-c67df10befe1"> |

<br>

### 1-1. 마우스로 3D 스피커 모델 조작하기

사용자의 마우스 움직임에 따라 2D 화면에서 3D 모델을 움직이기 위해 총 **3단계**가 필요합니다.

<br>

<div align="center">
  <img width="800" alt="2D 화면에서 3D 모델 움직이기" src="https://github.com/user-attachments/assets/6ab044f9-359f-4831-856b-03355615b9ef">
</div>

<br>

이 프로젝트에서는 사용자가 3D 모델의 스피커를 배치하여 소리의 변화를 경험할 수 있습니다. 스피커를 배치하기 위해서는 사용자가 **2D 화면에서 3D 스피커 모델의 움직임**을 직접 조작해야 합니다.

#### (1) 다양한 해상도에서 매끄럽게 움직이려면?

> 다양한 2D 화면에 대응하기 위해서는 **NDC(Normalized Device Coordinates)** 좌표로 변환해야 합니다.

웹에서 사용 가능한 이 프로젝트는 사용자들이 다양한 해상도와 화면 비율을 갖고 있는 모니터로 접근합니다. 이러한 다양성 때문에 고정된 화면 크기를 기준으로 좌표를 계산하면 다른 해상도나 비율의 화면에서는 3D 공간에서의 위치 계산이 부정확해질 수 있습니다. 예를 들어, 개발 당시 설정된 화면의 해상도와 비율이 사용자의 모니터와 다를 경우, 사용자가 마우스로 모델을 조작하려 할 때 모델이 의도하지 않은 방향으로 이동하는 문제가 발생할 수 있습니다. 이는 화면 좌표와 3D 공간 좌표의 매핑 오류로 인해 사용자 경험에 혼란을 줄 수 있습니다.

이러한 문제점을 해결하기 위해 프로젝트 화면의 좌표를 **NDC** 좌표로 변환하여 사용자의 모니터 해상도와 비율에 맞는 독립적인 좌표를 설정합니다. **NDC** 좌표로 변환하는 과정은 화면의 모든 좌표를 `-1`에서 `1` 사이의 값으로 **정규화**하는 것입니다.

<br>

<div align="center">
  <img width="400" alt="스크린샷 2024-10-24 오전 7 11 43" src="https://github.com/user-attachments/assets/d12ae7cc-7fde-4a6b-b958-c3b042c4e809">

_프로젝트 화면 NDC 좌표 변환_

</div>

<br>

#### (2) 2D 화면에서 3D 모델의 좌표 구하기

> 2D 화면에서 대응하는 3D 모델의 좌표를 구하기 위해 **광선(Ray)** 을 생성합니다.

2D 화면에서 3D 좌표를 직접 구할 수 없는 이유는 **깊이** 정보가 없기 때문입니다. 이를 해결하기 위해 2D 화면과 3D 공간을 연결하는 **광선** 투사 방식을 사용합니다. 화면상의 마우스 위치에서 3D 공간으로 **광선**을 발사하여, 광선이 3D 모델과 만나는 지점의 거리를 측정합니다. 이를 통해 마우스 위치에 대응하는 3D 공간의 `[x, y, z]` 좌표를 얻을 수 있습니다.

<br>

<div align="center">
  <img width="500" alt="광선 생성" src="https://github.com/user-attachments/assets/8b04c502-5083-4fa8-a17a-9fa3cd79e095">

_광선 생성을 통한 z축 좌표 계산_

 </div>

 <br>

#### (3) 마우스와 3D 모델의 실시간 상호작용

> 3D 스피커 모델과 마우스의 움직임이 서로 상호작용하기 위해 사용자가 움직인 3D 모델의 `[x, y, z]` 좌표를 **마우스 이벤트와 연결**합니다.

사용자가 마우스로 스피커를 배치할 수 있도록 마우스 **드래그** 이벤트를 활용합니다. **드래그를 시작**할 때 마우스 위치를 기준으로 스피커의 초기 좌표를 저장하고, **드래그 중**에는 마우스 움직임에 따라 스피커의 `[x, y, z]` 좌표를 실시간으로 업데이트하여 화면상의 위치 변화를 반영합니다.

<br>

<div align="center">
<img width="800" src="https://github.com/user-attachments/assets/7eab4882-2104-4414-b9cc-cd96099cfe6b">

_마우스 이벤트와 3D 모델 좌표 실시간 연동_

</div>

<br>

위와 같은 **3단계**의 과정을 통해 사용자는 2D 화면에서 3D 스피커 모델을 마우스로 **드래그하여 직접 배치**할 수 있습니다.

#### <p align="right"><a href="#top">목차👆🏼</a></p>

<br>

---

### 1-2. 스피커의 위치로 소리를 바꾸는 방식

공간에 따른 소리의 변화는 복잡한 과학적 원리가 내재되어 있습니다. 사용자가 조작한 스피커 위치에 따른 소리의 변화를 제공하기 위해 과학적 원리와 연관된 **세 가지** 소리의 특징만을 활용하였습니다.

1. 리스너와 스피커와의 **거리**에 따른 소리 변화

2. 스피커의 **좌우** 배치에 따른 소리 변화

3. 스피커의 **천장, 바닥** 배치에 따른 소리 변화

이 프로젝트에서는 사용자가 이러한 원리를 명확하게 체험할 수 있도록, 위와 같은 위치 요소를 통해 구현하였습니다.
아래 각 변화에 해당하는 내용을 자세히 설명하겠습니다.

#### (1) 멀리 갈수록 약해지는 소리

> 리스너로부터 스피커까지의 x, y, z축 거리를 활용하여 **소리의 감쇠효과**를 구현합니다.

**소리의 감쇠효과**는 리스너로부터 소리의 근원지가 멀어지면 볼륨이 감소하고 거리가 가까워지면 볼륨이 증가하는 현상을 의미합니다. 이 프로젝트에서는 소리의 근원지를 스피커로 설정하여 아래와 같이 구현하였습니다.

<br>

| 거리가 가까운 경우                                                                                                                                                  | 거리가 먼 경우                                                                                                                                                      |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <img width="400" height="260" alt="스크린샷 2024-10-24 오후 4 41 50" src="https://github.com/user-attachments/assets/f3d77ad2-a5c5-4b02-9dca-affbdb17997a"> | <img width="400" height="260" alt="스크린샷 2024-10-24 오후 4 42 05" src="https://github.com/user-attachments/assets/6014f8c2-7391-4f19-9939-341cbc4526fc"> |

<br>

사용자는 리스너로부터 스피커를 가까이 배치할 경우 볼륨이 증가하고 멀리 배치하는 경우 볼륨이 감소하는 현상을 경험할 수 있습니다. 리스너로부터 스피커 사이의 거리를 구하기 위해 실시간으로 각 모델의 `[x, y, z]` 좌표를 입력하여 **소리의 감쇠효과**를 보여줍니다.

#### (2) 좌우 위치에 따라 달라지는 소리

> 리스너로부터 스피커까지의 x, z축 거리를 활용하여 스피커의 **좌우 위치에 따른 소리의 세기차이**를 구현합니다.

스피커가 리스너의 왼쪽에 배치되면 왼쪽에서 들리는 소리가 강하게 오른쪽에 배치되면 오른쪽에서 소리가 강하게 들리는 현상을 기반으로 합니다. 이는 스피커의 위치에 따라 가까운 쪽 귀로 소리가 더 강하게 들어오고, 머리가 다른 쪽 귀로의 소리 전달을 약간 차단하기 때문입니다.

이 프로젝트에서는 리스너를 기준으로 스피커의 **좌우** 위치를 파악하기 위해 _cos_ 함수를 활용하였습니다.

_cos_ 함수 활용 방식은 아래와 같습니다.

1. 리스너를 중심으로 스피커와의 x축 ,z축 거리를 입력합니다.
2. 입력된 거리를 바탕으로 스피커와 리스너 사이의 각도를 계산합니다.
3. 계산된 각도를 _cos_ 함수에 대입하여 결과 값을 통해 스피커의 위치를 결정합니다.

| _cos_ (각도) | 값  | 위치   |
| ------------ | --- | ------ |
| _cos_ (180°) | -1  | 왼쪽   |
| _cos_ (90°)  | 0   | 중앙   |
| _cos_ (0°)   | 1   | 오른쪽 |

이 방식을 통해 _cos_ 값이 -1에 가까우면 스피커가 왼쪽에, 1에 가까우면 오른쪽에 배치된 것으로 분류합니다.

<br>

| 왼쪽 배치                                                                                                                                                           | 오른쪽 배치                                                                                                                                                         |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <img width="400" height="260" alt="스크린샷 2024-10-24 오후 5 46 37" src="https://github.com/user-attachments/assets/15a14891-a185-466b-834e-39fa1b8dbcf9"> | <img width="400" height="260" alt="스크린샷 2024-10-24 오후 5 46 49" src="https://github.com/user-attachments/assets/c4a2080b-65c1-4e6b-a855-c78d80c6f369"> |

<br>

사용자는 스피커를 왼쪽에 배치할 때 왼쪽 소리가 강조되고 오른쪽에 배치할 때 오른쪽 소리가 강조되는 경험을 할 수 있습니다. 리스너로부터 스피커의 x, z축 거리를 활용하여 스피커 **좌우** 배치에 따른 **소리의 세기 차이**를 보여줍니다.

#### (3) 천장과 바닥의 소리 차이: 주파수

> 스피커의 **주파수 음역대**의 특징을 활용하여 수직 배치에 따른 소리의 차이를 구현합니다.

사용자에게 스피커 배치에 따라 달라지는 소리의 차이를 직관적으로 제공하기 위해, 단순히 볼륨 차이만이 아니라 주파수 음역대의 변화를 추가 구현하기로 결정했습니다. 특히, 스피커의 위치에 따라 주파수 음역대가 어떻게 달라지는지 명확한 구분이 필요했습니다.

이를 구분하기 위해 먼저 주파수 음역대의 특징을 살펴보았습니다.

- 고주파 음역대는 짧은 파장을 가지기 때문에 다른 물체에 쉽게 흡수되어 부드러운 방의 **바닥**에서 약하게 전달됩니다.
- 저주파 음역대는 긴 파장을 가지며, 이로 인해 딱딱한 **천장**에 부딪혀도 쉽게 반사되어 그대로 전달됩니다.

이 프로젝트에서는 이러한 주파수 음역대의 특성을 활용하여 사용자가 스피커의 **수직** 위치 변경에 따라 고주파 음역대가 어떻게 다르게 전달되는지 체험할 수 있게 하였습니다.

<br>

| 바닥 배치                                                                                                                                                           | 천장 배치                                                                                                                                                           |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <img width="400" height="260" alt="스크린샷 2024-10-24 오후 7 30 55" src="https://github.com/user-attachments/assets/8caf900f-4e91-43b8-bb2b-e8293bf4d97f"> | <img width="400" height="260" alt="스크린샷 2024-10-24 오후 7 31 18" src="https://github.com/user-attachments/assets/3294442d-62a0-4c57-9769-72ffaf19a2bd"> |

<br>

**바닥** 가까이에 설치된 스피커는 고주파 음역대가 흡수되어 약하게 전달되어 상대적으로 저주파 음역대를 강조한 풍부하고 깊은 베이스를 경험할 수 있도록 설계하였습니다. 반면 **천장** 가까이에 설치된 스피커는 고주파 음역대가 흡수되지 않고 그대로 반사되어 고주파 음역대를 강조한 섬세하고 선명한 소리를 제공하도록 구현하였습니다.

<br>

위와 같은 **세 가지 위치 요소**를 고려한 스피커 배치로 사용자에게 **다양한 음향 변화**를 제공합니다.

#### <p align="right"><a href="#top">목차👆🏼</a></p>

<br>
<br>

## 2. 사용자 편의성을 위한 도전들

이 프로젝트에서의 사용자 경험을 증진하기 위해, 다음과 같은 기능을 추가하였습니다.

- **자동 저장 기능**: 시스템 오류, 저장 버튼 누락 등 예상치 못한 상황 속에서 사용자의 스피커 배치 **데이터를 안전하게 저장**하기 위해 자동 저장 방식을 도입하였습니다. 또한, **데이터 변경 감지**와 **중복 방지 로직**을 활용하여 효율적으로 작업을 진행하도록 구현하였습니다.

- **프리로드 기능**: 느린 네트워크 환경에서 발생할 수 있는 **3D 애플리케이션의 불편함을 최소화**하기 위해 필요한 3D 리소스를 사전에 로드하는 **프리로딩** 기능을 도입하였습니다. 또한, 불러온 3D 모델과 텍스처를 **캐싱**하고 **재사용**하여 불필요한 리소스 요청을 줄이도록 구현하였습니다.

<br>

### 2-1. 잊어버려도 괜찮아요, 자동 저장

#### (1) 저장 버튼만 존재하는 불편한 세상

만약 사용자가 스피커 배치 정보를 저장하기 위해 버튼을 눌러야만 하는 경우, 발생할 수 있는 문제점들을 아래와 같이 고민하였습니다.

1. **데이터 손실 발생**:
   사용자가 스피커를 배치하던 중 시스템 오류, 네트워크 문제 또는 의도치 않은 브라우저 종료 등으로 인해 **작업 중인 데이터를 잃어버릴 위험**이 존재합니다. 이러한 경우, 사용자는 모든 작업을 처음부터 다시 진행해야 하는 불편함을 겪게 될 수 있습니다.

2. **저장 버튼의 불편함**:
   저장 버튼을 수동으로 클릭해야 하는 방식은 사용자 경험을 저해할 수 있습니다. 특히, 사용자가 스피커 배치 작업에 집중하다 보면 **저장 버튼 클릭을 잊거나 번거롭게 느낄 가능성**이 높습니다. 자동 저장 기능이 없는 경우 사용자는 “저장”이라는 작업을 지속적으로 의식해야 하고, 이는 프로젝트의 목표인 직관적이고 원활한 사용자 경험을 방해한다고 생각했습니다.

이러한 문제들을 해결하기 위해, 사용자가 별도의 작업 없이 데이터가 주기적으로 저장되는 기능이 필요하다고 판단하였습니다. 이를 통해 사용자가 걱정없이, 저장 버튼 클릭과 같은 반복적인 작업 없이도 스피커 배치에만 집중할 수 있는 환경을 제공하고자 **자동 저장 기능**을 도입하기로 결정하였습니다.

#### (2) 자동 저장 구현하기

**자동 저장** 기능을 단순히 주기적으로 실행할 경우, 수시로 저장이 이루어지거나 중복 데이터가 저장되어 불필요한 작업이 발생하는 문제점을 해결하기 위해 두 가지 조건을 설정하여 모두 만족할 때만 자동 저장이 실행되도록 설계하였습니다.

<br>

<div align="center">
   <img width="400" alt="자동 저장" src="https://github.com/user-attachments/assets/134ae27f-862e-402e-a027-3722f9ba91bb">

</div>

<br>

- **5초** 동안 스피커나 리스너 배치가 **바뀌었나요?**<br>
  자동 저장 기능이 수시로 실행되는 경우 불필요한 연산이 발생하여 **성능 저하**를 일으킬 수 있다고 판단하였습니다. 따라서 **5초**라는 대기 시간과 **변경**이 있을 때만 처리하여 성능 저하없이 정보를 효율적으로 저장하기 위해 해당 조건을 설정하였습니다.

- 데이터 베이스에 저장된 배치와 **다른가요?**<br>
  사용자의 스피커 배치 정보는 **데이터 베이스**로 저장됩니다. 데이터 베이스에 저장하기 위해서는 **서버**에 요청을 하는 과정을 거치는데 이 요청은 **네트워크 트래픽**과 관련이 있습니다. 이 요청이 많아진다면 서버에 부하가 생길 수 있습니다. 그리하여 중복된 스피커 배치 정보는 불필요하다고 생각하여 **서버 부하를 줄이기 위해** 해당 조건을 설정하였습니다.

<br>

#### (3) 자동 저장이 가져다주는 편리함

이러한 자동 저장 기능을 통해 사용자는 예상치 못한 시스템 오류나 네트워크 문제로 인한 **데이터 손실 위험**을 줄일 수 있었습니다. 또한, 조건부 자동 저장 방식을 적용하여 불필요한 **서버 요청과 연산을 최소화**하는 데 기여할 수 있었습니다. 결과적으로, *Google Docs*와 같은 현대적인 웹 애플리케이션에서 필수적으로 사용되는 자동 저장 기능을 프로젝트에 효과적으로 도입하여 **사용자 경험을 향상**시킬 수 있었습니다.

<br>

| Google Docs                                                                                                          | Soundrag                                                                                                             |
| -------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| <img width="360" height="260" src="https://github.com/user-attachments/assets/4647616e-cc98-4cbb-bed8-e5f7931df880"> | <img width="360" height="260" src="https://github.com/user-attachments/assets/ada7ea77-1081-4e45-b843-eb54f5295609"> |

<br>

#### <p align="right"><a href="#top">목차👆🏼</a></p>

<br>

### 2-2. 빠른 속도의 비밀, 프리로드

#### (1) 느린 네트워크를 극복하기 위한 고민

이 프로젝트에서는 3D 모델과 텍스처 데이터를 반드시 필요로 하며, 이로 인해 **리소스의 로딩 시간**이 사용자 경험에 직접적인 영향을 미친다고 생각합니다. 하지만 네트워크가 느린 경우, 아래와 같이 3D 모델이나 텍스처가 로드되지 않아 사용자에게 빈 화면이 노출되어 애플리케이션이 제대로 작동하지 않는 것처럼 보일 수 있습니다.

<br>

<div align="center">
  <img width="600" src="https://github.com/user-attachments/assets/3750cf01-d00a-47d2-85ba-7ac208948997">
</div>

<br>

이와 같은 문제는 3D 환경에서 **매끄럽지 못한 사용자 경험**을 제공할 수 있는 치명적인 단점을 초래할 위험이 있다고 판단하였습니다. 이를 해결하기 위해 애플리케이션이 시작 단계에서 3D 리소스를 미리 로드하는 **프리로드** 기능을 설계하고 도입하기로 결정하였습니다.

#### (2) 프리로드 구현하기

프리로드는 애플리케이션 초기 단계에서 사용자가 탐색하게 될 필요한 리소스를 미리 불러오는 과정으로, 빈 화면 노출과 미완성 렌더링과 같은 문제점을 해결하기 위해 아래와 같이 구현하였습니다.

- **진입 페이지 구현**:
  애플리케이션이 실행되는 즉시, **사용자가 인터페이스를 탐색하기 전**에 필요한 모든 리소스를 백그라운드에서 로드하도록 설계하였습니다. 이 때, 초기 로딩 화면으로 **진입 페이지**를 구현하여 해당 페이지에서 백그라운드로 리소스를 미리 로드하도록 구현하였습니다.

- **리소스 로딩 최적화**:
  3D 모델과 텍스처 데이터를 불러올 때, 비동기 방식으로 로드하여 리소스가 효율적으로 준비되도록 최적화하였습니다. 추가로 로드된 리소스를 메모리에 **캐싱**함으로써 동일한 리소스에 대한 **중복 네트워크 요청을 방지**하였고, 이후 화면 전환 시에도 빠르고 일관된 렌더링을 제공할 수 있게 되었습니다.

#### (3) 프리로드가 가져다주는 편리함

이러한 프리로드 기능을 도입함과 동시에 진입 페이지를 구현하면서 3D 모델과 텍스처를 불러온 상태로 다음 페이지 전환되기 때문에 사용자가 빈 화면을 경험할 일이 사라졌습니다. 결과적으로 네트워크 상태와 관계없이 안정적으로 리소스를 불러오면서 사용자가 3D 화면을 탐색하기 전에 모든 리소스가 로드된 상태를 보장하면서 3D 화면으로의 전환 과정에서 발생할 수 있는 불편함을 최소화하여 **사용자 경험을 최적화**하였습니다.

<br>

<div align="center">
  <img width="600" src="https://github.com/user-attachments/assets/332cfd1b-88cf-4a66-98f4-8e7a0c588570">
</div>

<br>

#### <p align="right"><a href="#top">목차👆🏼</a></p>

<br>
<br>

## 3. 구현하며 배운 점들

#### (1) 3D 구현 도전

3D와 관련된 기능들을 구현하기 위해 수학적 개념에 대한 이해가 필요했습니다. 특히 3D 모델의 움직임과 회전 변환을 구현하기 위해 벡터에 대한 개념도 이해해야 했습니다. 관련 전공자가 아니다 보니 매우 어려웠지만, 평소 관심있었던 주제를 구현하기 위해 도움이 될 만한 개념이라 **배워가는** 과정이 모두 흥미로웠습니다.

#### (2) 소리 변화 구현

평소 음악과 스피커에 관심이 많다고 생각했던 스스로를 돌아볼 수 있는 시간이었습니다. 생각보다 복잡했던 소리의 전달 방식을 완벽하게 구현하지 못했지만 사용자들에게 의미 있는 경험을 제공하기 위해 방식을 **고민하고 설계**하는 과정은
매우 재미있었습니다.

#### (3) 사용자 중심 설계

프로젝트를 진행하면서 기술적 구현 못지 않게 사용자 경험이 매우 중요하다는 것을 깨달았습니다. 다양한 사용자 그룹을 대상으로 테스트하면서 그 피드백을 기반으로 인터페이스와 기능들을 수정했습니다. 이러한 과정을 통해 사용자 경험을 향상시킬 수 있는 **기능 구현**과 이를 위한 **기획 단계**의 중요성을 느낄 수 있었습니다.

#### <p align="right"><a href="#top">목차👆🏼</a></p>
