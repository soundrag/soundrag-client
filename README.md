<div align="center">
  <br>
  <br>

  <img width="300px" alt="project icon" src="https://github.com/user-attachments/assets/8f54c1ef-ac76-4dc0-a35a-4bc50a165fcc">

  <br>
  <br>

  <a href="https://soundrag-31cbb.web.app/">
    <img src="https://github.com/user-attachments/assets/10869a25-1536-44ca-8eca-adbe3370fa13">
  </a>

  <br>
  
  ### _스피커를 드래그하면서 소리의 차이를 경험할 수 있는 웹 3D 가상 시뮬레이터입니다._

</div>

### Client

![React](https://img.shields.io/badge/react-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB)
![Three.JS](https://img.shields.io/badge/Three.js-333333?style=for-the-badge&logo=Three.js&logoColor=white)
![Vite](https://img.shields.io/badge/vite-%23646CFF.svg?style=for-the-badge&logo=vite&logoColor=white)
![Zustand](https://img.shields.io/badge/zustand-%2320232a.svg?style=for-the-badge&logo=react&logoColor=white)
![Styled-components](https://img.shields.io/badge/styled_component-DB7093.svg?style=for-the-badge&logo=styledcomponents&logoColor=white)

### Server

![NodeJS](https://img.shields.io/badge/node.js-6DA55F?style=for-the-badge&logo=node.js&logoColor=white)
![Express.js](https://img.shields.io/badge/express.js-%23404d59.svg?style=for-the-badge&logo=express&logoColor=%2361DAFB)
![MongoDB & Mongoose](https://img.shields.io/badge/MongoDB%20&%20Mongoose-%234ea94b.svg?style=for-the-badge&logo=mongodb&logoColor=white)

<br>
<br>

## 목차

<!-- toc -->

- [**1️. 소개**](#1%EF%B8%8F-%EC%86%8C%EA%B0%9C)
  - [**1-1. Soundrag는 무엇인가요?**](#1-1-soundrag%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)
  - [**1-2. Soundrag는 왜 만들었나요?**](#1-2-soundrag%EB%8A%94-%EC%99%9C-%EB%A7%8C%EB%93%A4%EC%97%88%EB%82%98%EC%9A%94)
- [**2️. 기능**](#2%EF%B8%8F-%EA%B8%B0%EB%8A%A5)
  - [**2-1. 소리 변화**](#2-1-%EC%86%8C%EB%A6%AC-%EB%B3%80%ED%99%94)
  - [**2-2. 모델 조작**](#2-2-%EB%AA%A8%EB%8D%B8-%EC%A1%B0%EC%9E%91)
  - [**2-3. 위치 저장**](#2-3-%EC%9C%84%EC%B9%98-%EC%A0%80%EC%9E%A5)
- [**3️. 챌린지**](#3%EF%B8%8F-%EC%B1%8C%EB%A6%B0%EC%A7%80)
  - [**3-1. 공간 음향**](#3-1-%EA%B3%B5%EA%B0%84-%EC%9D%8C%ED%96%A5)
    - [**위치에 따라 달라지는 소리의 원리**](#%EC%9C%84%EC%B9%98%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%8B%AC%EB%9D%BC%EC%A7%80%EB%8A%94-%EC%86%8C%EB%A6%AC%EC%9D%98-%EC%9B%90%EB%A6%AC)
    - [**API를 활용하여 공간 음향 구현하기**](#api%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EC%97%AC-%EA%B3%B5%EA%B0%84-%EC%9D%8C%ED%96%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)
    - [**사용자와 스피커의 위치에 따른 공간 음향 구현하기**](#%EC%82%AC%EC%9A%A9%EC%9E%90%EC%99%80-%EC%8A%A4%ED%94%BC%EC%BB%A4%EC%9D%98-%EC%9C%84%EC%B9%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B3%B5%EA%B0%84-%EC%9D%8C%ED%96%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)
    - [**스피커의 수평적 움직임에 따른 공간 음향 구현하기**](#%EC%8A%A4%ED%94%BC%EC%BB%A4%EC%9D%98-%EC%88%98%ED%8F%89%EC%A0%81-%EC%9B%80%EC%A7%81%EC%9E%84%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B3%B5%EA%B0%84-%EC%9D%8C%ED%96%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)
    - [**스피커의 수직적 움직임에 따른 공간 음향 구현하기**](#%EC%8A%A4%ED%94%BC%EC%BB%A4%EC%9D%98-%EC%88%98%EC%A7%81%EC%A0%81-%EC%9B%80%EC%A7%81%EC%9E%84%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B3%B5%EA%B0%84-%EC%9D%8C%ED%96%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)
  - [**3-2. 자동 저장**](#3-2-%EC%9E%90%EB%8F%99-%EC%A0%80%EC%9E%A5)
    - [**서버 요청 없이 클라이언트에서 자동 저장하기**](#%EC%84%9C%EB%B2%84-%EC%9A%94%EC%B2%AD-%EC%97%86%EC%9D%B4-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EC%84%9C-%EC%9E%90%EB%8F%99-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0)
    - [**새로고침해도 지워지지 않는 상태 관리**](#%EC%83%88%EB%A1%9C%EA%B3%A0%EC%B9%A8%ED%95%B4%EB%8F%84-%EC%A7%80%EC%9B%8C%EC%A7%80%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC)
  - [**3-3. 메시지 알림**](#3-3-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%95%8C%EB%A6%BC)
    - [**사용자에게 메시지를 알려주는 기준**](#%EC%82%AC%EC%9A%A9%EC%9E%90%EC%97%90%EA%B2%8C-%EB%A9%94%EC%8B%9C%EC%A7%80%EB%A5%BC-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%8A%94-%EA%B8%B0%EC%A4%80)
    - [**사용자에게 반드시 알려줘야 하는 메시지**](#%EC%82%AC%EC%9A%A9%EC%9E%90%EC%97%90%EA%B2%8C-%EB%B0%98%EB%93%9C%EC%8B%9C-%EC%95%8C%EB%A0%A4%EC%A4%98%EC%95%BC-%ED%95%98%EB%8A%94-%EB%A9%94%EC%8B%9C%EC%A7%80)
    - [**사용자에게 가볍게 알려줘도 되는 메시지**](#%EC%82%AC%EC%9A%A9%EC%9E%90%EC%97%90%EA%B2%8C-%EA%B0%80%EB%B3%8D%EA%B2%8C-%EC%95%8C%EB%A0%A4%EC%A4%98%EB%8F%84-%EB%90%98%EB%8A%94-%EB%A9%94%EC%8B%9C%EC%A7%80)

<!-- tocstop -->

## 1️. 소개

### 1-1. Soundrag는 무엇인가요?

Soundrag는 ‘소리’를 의미하는 Sound와 ‘끌다’를 의미하는 Drag의 합성어로, 소리를 드래그하여 원하는 위치로 이동시킨다는 의미를 담고 있습니다. 웹 기반의 3D 시뮬레이터로, 사용자가 스피커와 자신의 위치를 자유롭게 이동시키며 **공간 음향**의 변화를 실시간으로 경험할 수 있는 도구입니다. 마치 소리를 손으로 끌어당기는 것처럼, 스피커와 사용자의 위치를 조절하여 다양한 음향 효과를 체험할 수 있습니다.

### 1-2. Soundrag는 왜 만들었나요?

콘서트장에서 좌석의 가격은 위치에 따라 다릅니다. 이는 좌석 위치에 따라 청취자가 경험하는 음향이 달라지기 때문입니다. 집에서도 스피커의 배치와 청취 위치에 따라 음향 품질이 크게 달라집니다. 캐나다 국립연구위원회(NRC)의 수석 연구원이었던 Floyd Toole은 가정에서 최적의 청취 경험을 위해 스피커 배치의 중요성을 강조하였습니다.

하지만 실제로 스피커를 이동하거나 최적의 위치를 찾는 것은 시간과 노력이 많이 소요됩니다. Soundrag는 이러한 문제를 해결하기 위해 가상 공간에서 스피커와 청취자의 위치를 자유롭게 조절할 수 있는 환경을 제공합니다. 이를 통해 사용자는 다양한 스피커 배치를 시도해보고, 위치 변화에 따른 음향 변화를 직접 체험함으로써 **공간 음향**에 대한 이해를 높일 수 있습니다.

## 2️. 기능

### 2-1. 소리 변화

> 사용자가 3D 공간에서 스피커와 자신의 위치에 따라 실시간으로 달라지는 소리를 경험할 수 있도록 하는 기능입니다. <br>

- 모델의 위치가 변경될 때 마다 재생되는 음원의 소리 차이를 경험할 수 있습니다.

### 2-2. 모델 조작

> 사용자가 3D 공간에서 스피커와 자신의 위치를 자유롭게 이동할 수 있도록 하는 기능으로 아래 세 가지 모드로 모델 조작이 가능합니다.

- **시점 모드**
  <div>
    <img width="800px" src="https://github.com/user-attachments/assets/ad238117-9af8-46d6-8e57-7003a4b66300">
  </div>

  - 마우스로 드래그하면 시점의 방향을 조절할 수 있습니다.
  - 마우스 휠을 사용하면 시점의 거리를 조절할 수 있습니다.

- **드래그 모드**
  <div>
  <img width="800px" src="https://github.com/user-attachments/assets/b2a3d56a-e496-4238-a60d-b96cd43560f9">
  </div>

  - 모델을 드래그하여 수평 이동이 가능합니다.
  - 스피커의 경우, Shift 키를 누른 채 모델을 클릭하면 수직 이동(천장, 바닥)이 가능합니다.

- **회전 모드**
  <div>
    <img width="800px" src="https://github.com/user-attachments/assets/62a8e2cc-8efc-4c55-9f99-5ee6bc0dc8b5">
  </div>

  - 스피커의 경우, 모델을 클릭하면 반시계방향으로 90도씩 각도 조절이 가능합니다.

### 2-3. 위치 저장

> 사용자가 3D 공간에서 스피커와 자신의 최적의 위치를 기억하고 사용할 수 있도록 하는 기능입니다. <br>

<div>
  <img width="800px" src="https://github.com/user-attachments/assets/18a65732-b646-443f-acf5-b68865213508">
</div>

  - 위치를 저장하고 불러오는 기능은 Google 계정을 연동하여 사용 가능합니다.

## 3️. 챌린지

### 3-1. 공간 음향

> 스피커와 청취자의 위치에 따라 소리가 어떻게 들리는지를 구현하기 위해서는 **공간 음향**이라는 개념이 필요했습니다. **공간 음향**은 소리의 방향과 거리에 따라 소리가 어떻게 변하는지를 나타내는 것으로 Soundrag에서는 이러한 원리를 활용하여 사용자가 위치를 이동함에 따라 실시간으로 소리의 변화를 느낄 수 있도록 구현하기로 결정했습니다

#### **위치에 따라 달라지는 소리의 원리**

공간 음향을 구현하기 위해 **HRTF(Head Related Transfer Function)**, **IID(Interaural Intensity Difference)**, 그리고 고주파 및 저주파 음파의 **반사 및 흡수** 특성을 활용하였습니다.

1. 소리는 인간의 머리와 귀의 구조로 인해 귀에 도달할 때 미세한 시간 차이와 주파수 응답 변화를 겪습니다. 이러한 현상을 수학적으로 모델링한 **HRTF**는 소리가 특정 위치에서 특정 방향으로 귀에 도달할 때의 주파수 응답과 시간 차이를 나타냅니다. 이를 통해 스피커와 사용자의 위치 변화에 따라 소리의 방향성과 거리감을 구현하였습니다.

   ```
   // 직접 제작한 거리 감쇠 시각 자료 추가 예정
   ```

   위 그림과 같이 **HRTF**는 사용자의 [x, y, z] 값과 스피커의 [x, y, z] 값을 비교하여 거리가 멀어질 때 마다 소리가 줄어들고, 거리가 가까워질 때 소리가 커지는 **거리 감쇠**라는 개념을 사용합니다.

2. 스피커의 수평적 움직임에 따라 소리는 **IID** 현상이 발생합니다. **IID**는 소리가 두 귀에 도달할 때의 음파의 에너지 수준 차이를 의미합니다. 예를 들어, 스피커가 왼쪽에 위치하면 왼쪽 귀에는 직접적인 소리가 더 강하게 도달하고, 오른쪽 귀에는 머리가 막고 있어 소리가 약해집니다. 이로 인해 왼쪽 소리가 더 크게 들리며, 뇌는 이 강도 차이를 이용해 소리의 방향을 인지합니다. 이러한 현상을 고려하여 스피커의 수평적 방향성을 구현하였습니다.

   ```
   // 직접 제작한 각도 관련 시각 자료 추가 예정
   ```

   위 그림과 같이 **IID**는 사용자의 [x, z] 값을 기준으로 스피커와의 [x, z] 값을 비교하여 거리를 활용한 각도를 계산한 값으로 왼쪽 오른쪽을 구분합니다.

3. 고주파 음파와 저주파 음파의 **반사 및 흡수** 특성을 활용하여 스피커의 수직적 움직임에 따른 음색 변화를 구현하였습니다. 고주파 음파는 파장이 짧아 벽이나 천장과 같은 표면에서 쉽게 반사되고, 저주파 음파는 파장이 길어 흡수되기 어렵습니다. 스피커가 천장에 가까워지면 고주파 성분이 **반사**되어 고주파 음역대가 강조되고, 바닥에 가까워지면 바닥 재질에 의해 고주파 성분이 **흡수**되어 상대적으로 저주파 음역대가 강조됩니다. 이를 통해 스피커의 높이에 따른 음색 변화를 구현하였습니다.

   ```
   // 직접 제작한 음파 흡수, 반사 관련 시각 자료 추가 예정
   ```

이 세 가지 원리는 서로 유기적으로 연결되어 있습니다. **HRTF**는 소리의 전반적인 방향성과 거리에 따른 변화를 모델링하고, **IID**는 좌우 귀에 도달하는 소리의 강도 차이를 통해 수평적 위치를 더욱 세밀하게 구분합니다. 여기에 고주파 및 저주파 음파의 **반사와 흡수** 특성을 적용하여 수직적 위치 변화에 따른 음색의 변화를 구현함으로써, Soundrag는 사용자에게 위치에 따른 소리의 직관적인 차이를 제공합니다.

#### **API를 활용하여 공간 음향 구현하기**

- _왜 API를 활용했나요?_

  Soundrag에서는 웹 브라우저에 내장된 **Web Audio API**를 활용하여 공간 음향 효과를 구현하였습니다. **Web Audio API**는 HTML `<audio>` 태그의 소스 파일에 있는 음원에 효과를 추가할 수 있는 도구입니다. 세밀한 음향 조절 작업이 가능한 장점도 있지만 이 API를 선택한 주된 이유는 웹 브라우저와의 **호환성**입니다. 모든 웹 브라우저에서 지원되어 사용자가 어떤 브라우저를 사용하더라도 일관된 공간 음향 효과를 경험할 수 있을 거라 생각했습니다.

- _어떻게 API를 활용했나요?_

  ```
  // 시각 자료로 대체 예정

  1. 음향 효과 처리 환경 생성하기

     - 음향 효과를 처리할 수 있는 노드를 가지고 있는 오디오 객체 생성

  2. 음원 불러오기

     - 음향 조절을 할 음원과 생성한 오디오 객체를 연결합니다.

  3. 음향 효과 처리 도구 생성하기

     - 추가하고 싶은 음향 효과와 관련된 노드를 생성합니다.

  4. 음향 효과 적용 하기
     - 음향 효과와 관련된 노드와 오디오 객체를 연결합니다.
     - 음향 효과와 관련된 노드와 음향 효과와 관련된 값을 적용합니다.
  ```

#### **사용자와 스피커의 위치에 따른 공간 음향 구현하기**

`PannerNode`는 사용자와 스피커의 위치를 기반으로 전반적인 공간 음향의 특성을 제공하는 노드입니다. 그 중 HRTF이라는 공간 음향 모델을 사용하여 스피커의 <ins>[x, y, z] 좌표 값을 통해 소리의 방향성과 거리감</ins>을 조절하였습니다.

- _HRTF 사용하기_

  ```jsx
  panner.panningModel = "HRTF";
  ```

- _[x, y, z] 좌표 값 적용하기_

  ```jsx
  const [x, y, z] = speakerPosition;

  panner.positionX.setValueAtTime(x, audio.currentTime);
  panner.positionY.setValueAtTime(y, audio.currentTime);
  panner.positionZ.setValueAtTime(z, audio.currentTime);
  ```

#### **스피커의 수평적 움직임에 따른 공간 음향 구현하기**

`StereoPannerNode`는 스피커의 좌우 위치에 따른 소리의 차이를 제공하는 노드입니다. 사용자를 기준으로 스피커의 x, z 좌표 값의 위치에 따라 달라지는 <ins>pan 값을 통해 소리의 좌우 밸런스</ins>를 조절하였습니다.

- _pan 값 구하기_

  ```jsx
  const calculatePan = (listenerPosition, speakerPosition) => {
    const distanceX = listenerPosition[0] - speakerPosition[0];
    const distanceZ = listenerPosition[2] - speakerPosition[2];

    const azimuth = Math.atan2(distanceX, distanceZ);

    const pan = Math.cos(azimuth);

    return pan;
  };
  ```

  - 사용자를 기준으로 스피커와의 x, z 좌표의 거리를 계산합니다.
  - 사용자를 기준으로 x, z 거리에 따른 각도를 계산합니다.
  - cos 함수를 활용하여 스피커의 위치와 pan 값을 계산합니다.

    | pan 값 | 위치   | cos 값    |
    | ------ | ------ | --------- |
    | -1     | 왼쪽   | cos (180) |
    | 0      | 중앙   | cos (90)  |
    | 1      | 오른쪽 | cos (0)   |

#### **스피커의 수직적 움직임에 따른 공간 음향 구현하기**

`BiquadFilterNode`는 소리의 특정 주파수 음역대를 조절하여 음색을 변경할 수 있는 노드입니다. 스피커가 <ins>바닥에 위치할 때는 저주파 음역대를 강조하고, 천장에 위치할 때는 고주파 음역대를 강조</ins>하였습니다.

- _특정 주파수 음역대 강조하기_

  ```jsx
  if (isAtFloor) {
    biquadFilter.type = "lowpass";
    biquadFilter.frequency.setValueAtTime(1000, audio.currentTime);
  } else if (isAtCeiling) {
    biquadFilter.type = "highpass";
    biquadFilter.frequency.setValueAtTime(1000, audio.currentTime);
  }
  ```

- _왜 수직적 움직임을 천장과 바닥으로 제한했나요?_

  - **과도한 자유도**: 스피커의 높이를 자유롭게 조절할 수 있도록 하면 사용자가 적절한 높이를 찾는데 피로감을 느낄 수 있다고 생각하여 조작을 단순화하였습니다.

  - **직관적 변화**: 바닥과 천장의 지형적 특성 상, 음의 흡수, 반사 현상이 두드러지게 드러납니다. 고주파, 저주파 음역대가 강조되는 음향 효과를 사용자에게 직관적으로 제공하기 위해 수직이동을 제한하였습니다.

### 3-2. 자동 저장

> 사용자는 위치 정보를 서버에 저장할 수 있습니다. 하지만 스피커와 리스너의 위치나 회전을 조정하면서 원하는 음향 효과를 세밀하게 설정하던 중, 실수로 페이지를 새로고침하거나 프로그램을 종료하면 지금까지의 작업 내용이 모두 사라질 수 있습니다. 이러한 문제는 사용자 경험을 저해한다고 판단하여, 서버에 요청하지 않고도 작업 내용을 **자동 저장**하여 사용자가 언제든지 이전 상태로 복원할 수 있는 기능을 구현하기로 결정했습니다.

#### **서버 요청 없이 클라이언트에서 자동 저장하기**

서버 요청 없이 클라이언트 측에서 일정한 간격으로 모델의 위치와 회전 정보를 저장하고 필요에 따라 복원하기 위해 상태 관리 라이브러리인 **Zustand**를 활용하여 자동 저장 기능을 구현하였습니다. 모델의 위치 정보와 회전 정보는 저장뿐만 아니라 오디오 조절, 서버 요청 저장, 모델 위치 변경 등 다양한 용도로 사용되기 때문에 전역 상태 관리가 필요하다고 판단하였습니다.

```
// 자동 저장, 복원 흐름 관련 시각 자료 추가 예정
```

- _자동 저장_

  - 상태 관리: **Zustand**를 통해 모델들의 위치와 회전 상태를 가져옵니다.
  - 변화 감지: 5초마다 현재 상태와 이전 상태를 비교합니다.
  - 자동 저장: 상태에 변화가 있을 경우, 위치와 회전 상태를 저장하고 사용자에게 알림을 표시합니다.

- _복원 기능_

  - 자동 저장 데이터 저장: 자동 저장된 데이터를 상태로 관리합니다.
  - 복원 기능: 자동 저장된 위치와 회전 정보 상태를 활용하여 복원할 수 있습니다.

#### **새로고침해도 지워지지 않는 상태 관리**

웹 서비스에서 사용자 경험을 향상시키기 위해 실수로 새로고침을 하거나 프로그램을 종료하더라도 상태를 유지하는 것이 중요하다고 생각합니다. 이를 위해 서버 요청 없이 클라이언트 측에서 데이터를 저장할 수 있는 두 가지 주요 방법인 **localStorage**와 **sessionStorage**에 대해 고민하였습니다.

- _localStorage_

  - 장점
    - 영구 저장: 사용자가 브라우저를 닫아도 데이터가 사라지지 않습니다.
  - 단점
    - 보안: 클라이언트 측에 영구적으로 저장되므로 민감한 데이터를 저장하는데 적합하지 않습니다.

- _sessionStorage_

  - 장점
    - 보안: 사용자가 브라우저를 닫으면 사라지기 때문에 비교적 안전합니다.
  - 단점
    - 영구 저장: 사용자가 브라우저를 닫으면 데이터가 사라집니다.

localStorage와 sessionStorage를 비교했을 때,

1. 위치 정보가 보안에 **민감하지 않은 정보**라고 판단

2. 실수로 브라우저나 탭을 닫은 경우, **데이터를 유지**할 필요가 있다고 판단

위와 같은 이유로 **localStorage**를 사용하기로 결정하였습니다.

### 3-3. 메시지 알림

> 사용자에게 정보를 전달하는 방법은 매우 다양합니다. 그러나 갑작스럽게 나타나는 모달 창이나 알림(alert) 창은 사용자의 작업 흐름을 방해하고 불편함을 줄 수 있습니다. 이러한 불편함 때문에 모든 알림을 제거하고 싶을 수 있지만, 사용자에게 반드시 전달해야 하는 중요한 정보도 존재합니다. 그렇다면 어떻게 하면 사용자 경험을 해치지 않으면서도 필요한 메시지를 효과적으로 전달할 수 있을지 고민했습니다.

```
// 사용자에게 메시지 알리는 기준 관련 시각 자료 추가 예정
```

#### **사용자에게 메시지를 알려주는 기준**

Soundrag에서는 사용자에게 알림을 제공하는 기준을 두 가지 원칙으로 정했습니다.

1. 사용자의 데이터에 **변화**를 주는 경우: 사용자의 데이터를 변화를 주는 작업을 진행할 때에 알립니다.

2. 사용자의 데이터에 **변화를 주지 않는** 경우: 사용자의 작업 흐름을 방해하지 않기 위해 서버에 요청을 보내더라도 데이터를 수정하지 않는다면 알리지 않습니다. 예를 들어, 사용자가 데이터를 조회할 때 데이터의 변경이 발생하지 않기 때문에 별도의 모달 없이도 사용자가 원하는 정보를 제공할 수 있습니다.

> 사용자의 데이터에 변화를 주는 경우에는 알림을 제공하지만 모든 알림을 모달로 할 필요가 없다고 생각했습니다. 사용자 경험을 증진시키기 위해 비교적 가벼운 toast를 활용하여 메시지는 알리되 불편함을 최소화하고자 또 기준을 나눴습니다.

#### **사용자에게 반드시 알려줘야 하는 메시지**

사용자의 데이터에 직접적인 영향을 미치는 작업에서는 반드시 알림을 통해 확인을 구해야 한다고 생각합니다. 왜냐하면 사용자가 실수로 원하지 않는 작업을 수행할 수도 있기 때문입니다. 이 위험을 방지하기 위해 데이터가 변경되는 작업에서는 사용자의 **의도를 재차 확인**하는 모달로 해결했습니다.

- 데이터 저장 전: 사용자가 정말로 저장을 원하는지 확인하는 모달을 띄웁니다.

- 데이터 삭제 전: 사용자가 정말 삭제를 원하는지 확인하는 모달을 띄웁니다. 하지만 삭제 후에는 화면에서 해당 데이터는 것을 사용자가 확인할 수 있기 때문에 추가적인 알림을 하지 않습니다.

#### **사용자에게 가볍게 알려줘도 되는 메시지**

모달로 확인 과정을 거치고 사용자가 요청을 했을 때, 그에 대한 **변화를 인지할 수 없는** 경우, 토스트 알림을 제공합니다.

- 데이터 자동 저장: 5초마다 사용자의 데이터 변화를 감지하고 저장하는 기능은 사용자가 저장되었는지 인지할 수 없기 때문에 toast 알림을 표시합니다.

- 데이터 서버 저장: 사용자가 서버로 데이터 저장 요청을 하더라도 저장이 되었는지 동일한 화면에서 인지할 수 없기 때문에 toast 알림을 표시합니다.
